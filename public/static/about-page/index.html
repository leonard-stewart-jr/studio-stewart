<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="publication-web-resources/css/main.css" rel="stylesheet" type="text/css">
    </link>
    <script src="publication-web-resources/script/main.js" type="text/javascript"></script>
    <!--
      Runtime enhancement script (keeps export intact):
      - Centers the exported HTML horizontally inside the content iframe
      - Makes images/SVG responsive inside the iframe
      - Hides common exported footers and any fallback text that mentions "If the frame does not load"
      - Styles the iframe's internal scrollbar to match the site tan color (#e6dbb9)
      This runs when the content iframe is loaded and for a short polling window to catch late asset loads.
    -->
    <script type="text/javascript">
      (function () {
        // Configuration
        var IFRAME_ID = 'contentIFrame';
        var STYLE_ID = 'about-iframe-enhance';
        var FALLBACK_PHRASE = 'If the frame does not load';
        var SCROLLBAR_COLOR = '#e6dbb9';
        var POLL_INTERVAL = 200; // ms
        var POLL_LIMIT = 30; // ~6s of polling

        function buildCss() {
          // Conservative, targeted rules to avoid breaking export behavior
          return '\
/* Normalize exported page so it centers and does not force an inner scroll container */\n\
html, body, #page, .page, .export-container, .adobe-export, .aep-export {\n\
  width: auto !important;\n\
  max-width: none !important;\n\
  box-sizing: border-box !important;\n\
  height: auto !important;\n\
  min-height: 0 !important;\n\
  margin: 0 !important;\n\
  padding: 0 !important;\n\
  overflow: visible !important;\n}\n\
/* Center exported content horizontally */\n\
body {\n\
  display: flex !important;\n\
  justify-content: center !important;\n\
  align-items: flex-start !important; /* preserve vertical flow */\n\
  background: transparent !important;\n}\n\
/* Ensure wrappers are centered */\n\
#page, .page, .export-container { margin-left: auto !important; margin-right: auto !important; }\n\
/* Make images and vector assets responsive inside export */\n\
img, svg, picture, figure { max-width: 100% !important; height: auto !important; display: block !important; }\n\
/* Hide exported footers â€” parent site provides chrome */\n\
footer, .site-footer, .page-footer, .export-footer { display: none !important; }\n\
/* Defensive: hide obvious fallback wrappers */\n\
.fallback, .iframe-fallback { display: none !important; }\n\
/* Scrollbar styling for WebKit browsers inside iframe */\n\
html::-webkit-scrollbar, body::-webkit-scrollbar { width: 14px; background: transparent; }\n\
html::-webkit-scrollbar-thumb, body::-webkit-scrollbar-thumb { background: ' + SCROLLBAR_COLOR + ' ; border-radius: 0; }\n\
html::-webkit-scrollbar-thumb:hover, body::-webkit-scrollbar-thumb:hover { background: #d6c08e; }\n\
/* Firefox scrollbar hint */\n\
body { scrollbar-width: thin; scrollbar-color: ' + SCROLLBAR_COLOR + ' #f0f0ed; }\n';
        }

        function removeFallbackNodes(doc) {
          try {
            if (!doc || !doc.body) return;
            var walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, null, false);
            var toRemove = [];
            var node;
            while ((node = walker.nextNode())) {
              try {
                if (node.textContent && node.textContent.indexOf(FALLBACK_PHRASE) !== -1) {
                  toRemove.push(node);
                }
              } catch (e) {
                // continue on access errors
              }
            }
            toRemove.forEach(function (n) {
              try { n.parentNode && n.parentNode.removeChild(n); } catch (e) {}
            });
          } catch (e) {
            // ignore
          }
        }

        function injectStyleIntoIframe(iframe) {
          try {
            var doc = iframe.contentDocument || iframe.contentWindow.document;
            if (!doc) return false;

            var css = buildCss();
            var existing = doc.getElementById(STYLE_ID);
            if (existing) {
              existing.textContent = css;
            } else {
              var style = doc.createElement('style');
              style.id = STYLE_ID;
              style.type = 'text/css';
              style.appendChild(doc.createTextNode(css));
              if (doc.head) doc.head.insertBefore(style, doc.head.firstChild);
              else doc.documentElement.insertBefore(style, doc.documentElement.firstChild);
            }

            // defensive removal of fallback text nodes (if any)
            removeFallbackNodes(doc);

            return true;
          } catch (err) {
            // cross-origin or other error
            return false;
          }
        }

        function enhanceIframeOnLoad(iframe) {
          var applied = injectStyleIntoIframe(iframe);
          // If we couldn't apply (maybe iframe doc not ready), bail; onload handler will retry.
          if (!applied) return;

          // Poll a few times to re-apply (handles late-loaded fonts/images or scripts)
          var count = 0;
          var poll = setInterval(function () {
            count += 1;
            injectStyleIntoIframe(iframe);
            if (count >= POLL_LIMIT) {
              clearInterval(poll);
            }
          }, POLL_INTERVAL);
        }

        function watchIframe() {
          var iframe = document.getElementById(IFRAME_ID);
          if (!iframe) return;

          // If already loaded and same-origin, attempt immediate injection
          try {
            var doc = iframe.contentDocument || iframe.contentWindow.document;
            if (doc && (doc.readyState === 'complete' || doc.readyState === 'interactive')) {
              // apply now
              enhanceIframeOnLoad(iframe);
            } else {
              // attach load handler (preserve any existing onload handlers)
              iframe.addEventListener('load', function () {
                // small timeout to allow export scripts to run first
                try { setTimeout(function () { enhanceIframeOnLoad(iframe); }, 50); } catch (e) {}
              });
            }
          } catch (e) {
            // If access throws, the iframe might not be same-origin (shouldn't be in your setup).
            // In that case we can't inject or style its scrollbar.
          }
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', watchIframe);
        } else {
          watchIframe();
        }
      })();
    </script>
  </head>

  <body onload="showHideArrows()">
    <iframe onload="showHideArrows()" id="contentIFrame" class="contentIframeClass" src="publication-web-resources/html/publication.html"></iframe>
    <iframe id="dummyIFrame" class="dummyFrameClass"></iframe>

    <div class="prev" onclick="showPreviousPage()">&#10094;</div>
    <div class="next" onclick="showNextPage()">&#10095;</div>
  </body>
</html>